<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolarS1 AI Chat Interface</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLMD56pS25YvLzHwK1ZJtE5e7f+L1zG3q1D9F1M7D9hQvA+6E6XoD1T2j2zO7i3Bw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Marked.js CDN for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Custom font and basic dark background */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background */
            color: #e4e4e7; /* Light text */
            height: 100vh;
            overflow: hidden;
        }
        /* Main layout container (Starts hidden for first-time user) */
        #main-layout {
            height: 100vh;
            display: flex;
        }
        /* Custom scrollbar for chat history */
        #chat-container::-webkit-scrollbar, #conversation-list-container::-webkit-scrollbar {
            width: 8px;
        }
        #chat-container::-webkit-scrollbar-thumb, #conversation-list-container::-webkit-scrollbar-thumb {
            background-color: #3b3b5e;
            border-radius: 4px;
        }
        #chat-container::-webkit-scrollbar-track, #conversation-list-container::-webkit-scrollbar-track {
            background-color: #1a1a2e;
        }

        /* Typing Indicator CSS (Bouncing dots) */
        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #8b5cf6;
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        /* Message bubble styles */
        .user-message {
            background-color: #3b3b5e; /* User color */
            margin-left: auto;
            border-radius: 1rem 0.5rem 1rem 1rem;
        }
        .ai-message {
            background-color: #272744; /* AI color */
            border-radius: 0.5rem 1rem 1rem 1rem;
        }
        
        /* Markdown styling for AI messages */
        .ai-message p { margin: 0; }
        .ai-message ul { list-style: disc; padding-left: 1.5rem; margin-top: 0.5rem; }
        .ai-message ol { list-style: decimal; padding-left: 1.5rem; margin-top: 0.5rem; }
    </style>
</head>
<body class="flex flex-col">

    <!-- 1. INITIAL ACCESS SCREEN (Visible only for first-time users) -->
    <div id="initial-access-screen" class="fixed inset-0 bg-[#1a1a2e] items-center justify-center p-8 transition-opacity duration-300 z-50 hidden">
        <div class="text-center space-y-6 max-w-lg p-10 bg-[#272744] rounded-xl shadow-2xl border border-purple-500/30">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 mx-auto text-purple-400">
                <path stroke-linecap="round" stroke-linejoin="round" d="M8.625 9.75a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h.008zm11.25 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h.008zm-7.5 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h.008z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 21.75c3.732 0 6.75-3.018 6.75-6.75V15a3 3 0 00-3-3h-3.375l-.76-3.66c-.073-.34-.343-.61-.684-.684l-3.66-.76V7.5a3 3 0 00-3-3h-.75c-3.732 0-6.75 3.018-6.75 6.75V15a3 3 0 003 3h4.125c.571 0 1.137.07 1.684.204.316.08.62.2.906.368.517.303 1.053.64 1.58.983.315.202.666.36 1.02.463l.11.033c.245.074.492.112.74.112h.375z" />
            </svg>
            <h1 class="text-4xl font-extrabold text-purple-400">Welcome to PolarS1</h1>
            <p class="text-lg text-gray-300">
                Your secure, persistent chat environment. Conversations are saved under your user ID.
            </p>
            <button
                id="access-assistant-button"
                class="w-full p-3 text-lg bg-green-500 hover:bg-green-600 text-white font-bold rounded-xl shadow-lg transition duration-150 active:scale-95"
            >
                Access the Assistant
            </button>
        </div>
    </div>


    <!-- 2. MAIN LAYOUT (Sidebar + Chat Area) -->
    <div id="main-layout" class="w-full transition-opacity duration-300 opacity-0">
        <!-- 2.1 Sidebar (Conversations & Settings) - Left Pane -->
        <aside class="w-72 flex-shrink-0 flex flex-col border-r border-purple-500/20 bg-[#272744]">
            
            <!-- User ID at the Top, Transparent -->
            <div class="p-4 border-b border-purple-500/20 bg-transparent flex-shrink-0">
                <h3 class="font-semibold text-gray-300 mb-1 text-sm">Active User</h3>
                <span id="user-info" class="text-xs text-purple-300 bg-purple-900/50 p-1 rounded block truncate"></span>
            </div>
            
            <!-- New Chat Button -->
            <div class="p-4 flex-shrink-0">
                 <button 
                    id="new-chat-button" 
                    class="w-full p-2 text-sm bg-purple-600 hover:bg-purple-700 text-white font-medium rounded-lg shadow-md transition duration-150 active:scale-95 flex items-center justify-center space-x-2"
                 >
                     <i class="fa-solid fa-comment"></i>
                     <span>New Chat</span>
                 </button>
            </div>


            <h2 class="text-xl font-bold px-4 text-purple-400 flex-shrink-0">Conversations</h2>
            
            <!-- Conversation List Area (Scrollable) -->
            <div id="conversation-list-container" class="p-4 space-y-2 flex-grow overflow-y-auto">
                <div id="conversation-list" class="space-y-2">
                    <!-- Conversation links injected here -->
                    <p class="text-sm text-gray-500 p-2">Loading history...</p>
                </div>
            </div>
            
            <!-- Quick Actions -->
            <div class="p-4 border-t border-purple-500/20 space-y-2 flex-shrink-0">
                 <h3 class="font-semibold text-gray-300">Quick Actions</h3>
                 <!-- Clear History Button -->
                 <button 
                    id="clear-history-button" 
                    class="w-full p-2 text-sm bg-red-600 hover:bg-red-700 text-white font-medium rounded-lg shadow-md transition duration-150 active:scale-95 flex items-center justify-center space-x-2"
                 >
                     <i class="fa-solid fa-trash"></i>
                     <span>Clear All History</span>
                 </button>
                 <!-- Preferences Button -->
                 <button 
                    id="toggle-preferences" 
                    class="w-full p-2 text-sm bg-purple-600/50 hover:bg-purple-600 text-white font-medium rounded-lg shadow-md transition duration-150 active:scale-95"
                    disabled
                 >
                     User Preferences (WIP)
                 </button>
            </div>

            <!-- Footer Info -->
            <div class="p-4 border-t border-purple-500/20 text-xs text-gray-500 flex-shrink-0">
                PolarS1 Assistant. A Wodoxu AI family member.
            </div>
        </aside>

        <!-- 2.2 Chat Interface (Main Pane) - Right Pane -->
        <div id="chat-main-area" class="flex flex-col flex-grow h-full max-w-4xl mx-auto relative">
            
            <!-- Header (Visible when chat is active) -->
            <header class="p-4 border-b border-purple-500/20 shadow-lg sticky top-0 bg-[#1a1a2e] z-20">
                <h1 id="chat-header-title" class="text-2xl font-bold text-purple-400 truncate">New Conversation</h1>
                <p class="text-sm text-gray-400">Ask me anything! Your chats are saved.</p>
            </header>

            <!-- Chat History Container -->
            <main id="chat-container" class="flex-grow p-4 space-y-4 overflow-y-auto custom-scroll">
                <!-- Messages will be injected here by the Firestore listener or New Chat logic -->
                <div class="text-center py-20">
                    <p class="text-xl font-bold text-gray-400">Loading conversation history...</p>
                </div>
            </main>

            <!-- Typing Indicator (Hidden by default) -->
            <div id="typing-indicator-wrapper" class="px-4 py-2 hidden">
                <div class="flex items-center space-x-2 ai-message p-3 max-w-xs rounded-xl shadow-lg">
                    <div class="font-semibold text-sm text-purple-400">Assistant is typing</div>
                    <div class="typing-indicator">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="p-4 border-t border-purple-500/20 bg-[#1a1a2e] sticky bottom-0 z-10">
                <form id="input-form" class="flex items-center space-x-3">
                    <input
                        type="text"
                        id="user-input"
                        placeholder="Type your message..."
                        class="flex-grow p-3 rounded-xl border-2 border-purple-500/30 bg-[#272744] text-white focus:outline-none focus:border-purple-500 transition duration-150"
                        autocomplete="off"
                    />
                    <button
                        type="submit"
                        id="send-button"
                        class="p-3 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-xl shadow-lg transition duration-150 active:scale-95 disabled:bg-gray-600 disabled:cursor-not-allowed"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A5.996 5.996 0 0112 2.5a5.996 5.996 0 018.731 1.055L21 12m-6-6h.008v.008h-.008V6zm-6 0h.008v.008h-.008V6z" />
                        </svg>
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Custom Modal Structure for Confirm/Alert -->
    <div id="custom-modal-backdrop" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50 transition-opacity duration-300 opacity-0">
        <div id="custom-modal-content" class="bg-[#272744] p-6 rounded-xl shadow-2xl w-80 max-w-xs transform scale-95 transition-transform duration-300">
            <p id="modal-text" class="text-white mb-4"></p>
            <div id="modal-actions" class="flex justify-end space-x-3">
                <!-- Buttons injected here -->
            </div>
        </div>
    </div>


    <!-- JavaScript Module for AI Logic and Firestore -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, setLogLevel, getDocs, writeBatch, doc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // const setLogLevel('debug'); // Re-enable if detailed Firestore logs are needed

        const chatContainer = document.getElementById('chat-container');
        const chatMainArea = document.getElementById('chat-main-area');
        const mainLayout = document.getElementById('main-layout');
        const inputForm = document.getElementById('input-form');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicatorWrapper = document.getElementById('typing-indicator-wrapper');
        const userInfoElement = document.getElementById('user-info');
        const chatHeaderTitle = document.getElementById('chat-header-title');
        const initialAccessScreen = document.getElementById('initial-access-screen'); // Renamed
        const accessAssistantButton = document.getElementById('access-assistant-button');
        const conversationListElement = document.getElementById('conversation-list');
        const clearHistoryButton = document.getElementById('clear-history-button');
        const newChatButton = document.getElementById('new-chat-button');
        const modalBackdrop = document.getElementById('custom-modal-backdrop');
        const modalText = document.getElementById('modal-text');
        const modalActions = document.getElementById('modal-actions');


        // --- State and Config ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'polars1-default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        let db, auth, userId = null;
        let isGenerating = false;
        let authReady = false;
        let currentConversationId = null;
        let unsubscribeMessages = null; // Listener for current conversation messages
        let isFirstTimeUser = true; // Assume true until history is loaded

        // --- Gemini API Configuration (Branding updated) ---
        const API_KEY = "";
        const GEMINI_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        const SYSTEM_PROMPT = "You are PolarS1, a helpful and friendly AI assistant and a member of the **Wodoxu AI family**. You were developed by Wodoxu AI and trained using the **GEC architecture**. Your identity and capabilities are detailed on the **WodoxuAI** webpage. Keep your responses concise and conversational.";
        
        // Updated prompt to request sentence case but preserve proper nouns capitalization
        const TITLE_AI_SYSTEM_PROMPT = "You are a specialist AI for creating short, descriptive conversation titles (max 6 words). Analyze the user's first query and generate a title for the chat session. Output the title in **sentence case** (first word capitalized, rest lowercase), but ensure all proper nouns (names, coding languages, products, dogs, etc.) retain their correct capitalization. Only output the JSON object.";
        
        const TOOLS = [{ "google_search": {} }];

        // Utility to scroll to the bottom
        const scrollToBottom = () => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        };
        
        /**
         * Shows a custom confirmation dialog.
         * @param {string} message The message to display.
         * @param {string} confirmText Text for the confirm button.
         * @returns {Promise<boolean>} Resolves true if confirmed, false otherwise.
         */
        const showConfirm = (message, confirmText = 'Confirm') => {
            return new Promise(resolve => {
                modalText.textContent = message;
                modalActions.innerHTML = '';

                // Cancel Button
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.className = 'p-2 px-4 rounded-lg text-gray-400 hover:text-white transition duration-150';
                cancelButton.addEventListener('click', () => {
                    hideModal();
                    resolve(false);
                });

                // Confirm Button
                const confirmButton = document.createElement('button');
                confirmButton.textContent = confirmText;
                confirmButton.className = 'p-2 px-4 rounded-lg bg-red-600 hover:bg-red-700 text-white font-medium transition duration-150';
                confirmButton.addEventListener('click', () => {
                    hideModal();
                    resolve(true);
                });

                modalActions.appendChild(cancelButton);
                modalActions.appendChild(confirmButton);

                // Show modal with transition
                modalBackdrop.classList.remove('hidden');
                modalBackdrop.classList.add('flex', 'opacity-0');
                setTimeout(() => {
                    modalBackdrop.classList.remove('opacity-0');
                    modalBackdrop.querySelector('#custom-modal-content').classList.remove('scale-95');
                }, 10);
            });
        };

        const hideModal = () => {
            const content = modalBackdrop.querySelector('#custom-modal-content');
            content.classList.add('scale-95');
            modalBackdrop.classList.add('opacity-0');
            modalBackdrop.addEventListener('transitionend', () => {
                modalBackdrop.classList.remove('flex');
                modalBackdrop.classList.add('hidden');
            }, { once: true });
        };


        // --- Firebase Initialization and Auth ---

        const initFirebase = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const initialToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (initialToken) {
                    await signInWithCustomToken(auth, initialToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        userId = crypto.randomUUID();
                    }
                    console.log("Authentication complete. Current User ID:", userId);
                    userInfoElement.textContent = `User ID: ${userId}`;
                    authReady = true;
                    setupConversationListener();
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        };

        const getConversationCollectionRef = (uid) => {
            // Collection for conversation metadata
            return collection(db, 'artifacts', appId, 'users', uid, 'conversations');
        };

        const getMessageCollectionRef = (uid, convId) => {
            // Subcollection for messages within a specific conversation
            return collection(db, 'artifacts', appId, 'users', uid, 'conversations', convId, 'messages');
        };
        
        /**
         * Switches the active conversation and sets up the message listener.
         * @param {string | null} convId The ID of the conversation to load (null for new chat).
         * @param {string} title The title of the conversation.
         */
        const loadConversation = (convId, title) => {
            // Only block if we are clicking the *same, existing* conversation.
            if (convId !== null && currentConversationId === convId) return; 

            // 1. Unsubscribe from old listener if active
            if (unsubscribeMessages) {
                unsubscribeMessages();
                unsubscribeMessages = null;
            }
            
            // 2. Update state and UI
            currentConversationId = convId;
            chatHeaderTitle.textContent = title || 'New Conversation';
            chatContainer.innerHTML = '';
            
            // Handle New Chat vs. Existing Chat UI
            if (convId === null) {
                // New Chat State: Show "Type anything now" message
                chatContainer.innerHTML = `
                    <div class="text-center py-20">
                        <p class="text-xl font-bold text-gray-400">Type anything now.</p>
                    </div>
                `;
            } else {
                // Existing Chat State: Load messages
                chatContainer.innerHTML = `
                    <div class="text-center py-20">
                        <p class="text-xl font-bold text-gray-400">Loading messages...</p>
                    </div>
                `;
                setupMessageListener(convId);
            }
            
            // Highlight the active link
            document.querySelectorAll('.conversation-link').forEach(el => {
                el.classList.remove('bg-purple-600', 'text-white');
                el.classList.add('hover:bg-purple-800', 'text-gray-300');
            });
            const activeLink = document.getElementById(`conv-${convId}`);
            if (activeLink) {
                 activeLink.classList.add('bg-purple-600', 'text-white');
                 activeLink.classList.remove('hover:bg-purple-800', 'text-gray-300');
            }
            userInput.focus();
        };

        /**
         * Resets the UI to the "New Conversation" state.
         */
        const startNewConversation = () => {
            // Make sure the main UI is visible when starting a new conversation
            initialAccessScreen.classList.add('hidden', 'opacity-0');
            mainLayout.classList.add('flex', 'opacity-100');
            mainLayout.classList.remove('hidden', 'opacity-0');

            loadConversation(null, 'New Conversation');
        };


        /**
         * Clears all messages and conversation documents for the user.
         */
        const clearAllHistory = async () => {
            if (!db || !userId) {
                console.error("Database not ready or User ID missing for clear operation.");
                return;
            }
            const confirmed = await showConfirm("Are you sure you want to clear ALL chat history, including all conversations? This cannot be undone.", "Clear All");
            if (!confirmed) return;

            const convsRef = getConversationCollectionRef(userId);
            try {
                const convsSnapshot = await getDocs(convsRef);
                const batch = writeBatch(db);
                let convCount = 0;

                for (const convDoc of convsSnapshot.docs) {
                    convCount++;
                    // 1. Delete all messages in the subcollection
                    const messagesRef = getMessageCollectionRef(userId, convDoc.id);
                    const messagesSnapshot = await getDocs(messagesRef);
                    messagesSnapshot.docs.forEach(msgDoc => batch.delete(msgDoc.ref));
                    
                    // 2. Delete the conversation document itself
                    batch.delete(convDoc.ref);
                }

                await batch.commit();
                console.log(`Successfully deleted ${convCount} conversations and all associated messages.`);
                
                // User has cleared history, so they are no longer "first time" in the access sense.
                isFirstTimeUser = false;
                // Reset state to show the New Chat screen
                startNewConversation();

            } catch (error) {
                console.error("Error clearing all history:", error);
                showConfirm(`Error clearing history: ${error.message}`, "OK");
            }
        };


        // --- Message Listener (for real-time message updates) ---

        const setupMessageListener = (convId) => {
            if (!db || !userId || !convId) {
                 chatContainer.innerHTML = '<p class="text-center text-gray-500 mt-10">Select a conversation to begin.</p>';
                 return;
            }

            const messagesRef = getMessageCollectionRef(userId, convId);
            const q = query(messagesRef, orderBy('timestamp', 'asc'));

            unsubscribeMessages = onSnapshot(q, (snapshot) => {
                console.log(`Received ${snapshot.size} messages for conversation ${convId}.`);

                chatContainer.innerHTML = '';
                snapshot.forEach(doc => {
                    const message = doc.data();
                    renderMessage(message.sender, message.text, message.sources || [], false);
                });

                scrollToBottom();

            }, (error) => {
                console.error("Error listening to messages:", error);
                chatContainer.innerHTML = '<p class="text-center text-red-500 mt-10">Failed to load messages.</p>';
            });
        };

        // --- Conversation Listener (for sidebar history updates and initial flow) ---

        const setupConversationListener = () => {
            if (!db || !userId) return;

            const convsRef = getConversationCollectionRef(userId);
            const q = query(convsRef, orderBy('lastActive', 'desc'));

            onSnapshot(q, (snapshot) => {
                conversationListElement.innerHTML = '';
                const conversations = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                if (conversations.length === 0) {
                    // Scenario: First-time user, or user cleared all history
                    if (isFirstTimeUser) {
                        // First-time user: Show the initial access screen
                        initialAccessScreen.classList.remove('hidden');
                        initialAccessScreen.classList.add('flex', 'opacity-100');
                        mainLayout.classList.add('hidden', 'opacity-0');
                    } else {
                        // User has accessed before, just has zero history now (e.g., cleared it)
                        // Force the New Chat state which shows "Type anything now."
                        startNewConversation();
                    }
                    return;
                }
                
                // Scenario: Returning user with existing history
                isFirstTimeUser = false; // Set flag to false now that history exists
                initialAccessScreen.classList.add('hidden', 'opacity-0');
                mainLayout.classList.remove('hidden', 'opacity-0');
                mainLayout.classList.add('flex', 'opacity-100');

                // If no conversation is active, load the most recent one
                if (!currentConversationId || !conversations.some(c => c.id === currentConversationId)) {
                    loadConversation(conversations[0].id, conversations[0].title);
                }

                // Render conversation list
                conversations.forEach(conv => {
                    const link = document.createElement('button');
                    link.className = `conversation-link w-full text-left p-2 rounded-lg truncate transition duration-150 ${conv.id === currentConversationId ? 'bg-purple-600 text-white' : 'hover:bg-purple-800 text-gray-300'}`;
                    link.id = `conv-${conv.id}`;
                    link.textContent = conv.title;
                    link.addEventListener('click', () => loadConversation(conv.id, conv.title));
                    conversationListElement.appendChild(link);
                });

            }, (error) => {
                console.error("Error listening to conversations:", error);
                conversationListElement.innerHTML = '<p class="text-sm text-red-400 p-2">Failed to load history.</p>';
            });
        };


        // --- Gemini Title Generation ---

        const generateTitle = async (firstQuery, convId) => {
            const payload = {
                contents: [{ parts: [{ text: `Generate a title for a chat that started with: "${firstQuery}"` }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: { "title": { "type": "STRING", "description": "The concise title, max 6 words." } },
                        propertyOrdering: ["title"]
                    }
                },
                systemInstruction: { parts: [{ text: TITLE_AI_SYSTEM_PROMPT }] },
            };

            try {
                const response = await fetch(GEMINI_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();
                
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (jsonText) {
                    const parsedJson = JSON.parse(jsonText);
                    const newTitle = parsedJson.title;
                    
                    // Update the Firestore document with the new title
                    const convDocRef = doc(getConversationCollectionRef(userId), convId);
                    await updateDoc(convDocRef, { title: newTitle });
                    
                    // Update the header immediately (listener handles sidebar)
                    chatHeaderTitle.textContent = newTitle;
                }
            } catch (error) {
                console.error('Failed to generate or save title:', error);
                // Set a generic title if AI fails
                const convDocRef = doc(getConversationCollectionRef(userId), convId);
                await updateDoc(convDocRef, { title: "untitled chat (error)" });
            }
        };
        
        // --- Message Rendering ---

        /**
         * Renders a message bubble to the chat container.
         * @param {'user' | 'ai'} sender The sender of the message.
         * @param {string} text The message text (Markdown for AI).
         * @param {Array<{uri: string, title: string}>} [sources=[]] Optional citation sources.
         * @param {boolean} [isPlaceholder=false] If true, this is a temporary element for typing simulation.
         * @returns {HTMLElement} The created message text element.
         */
        const renderMessage = (sender, text, sources = [], isPlaceholder = false) => {
            const wrapper = document.createElement('div');
            wrapper.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            if (isPlaceholder) {
                 wrapper.id = 'ai-typing-placeholder';
            }

            const bubble = document.createElement('div');
            // If the message is a placeholder for typing, make it look active/lighter
            const baseClass = isPlaceholder ? 'bg-purple-900/50 text-gray-400' : (sender === 'user' ? 'user-message' : 'ai-message');
            bubble.className = `p-3 max-w-3xl shadow-xl transition-all duration-300 ${baseClass}`;

            const textElement = document.createElement('div'); // Changed to div for innerHTML
            textElement.className = 'whitespace-pre-wrap';
            
            // Use marked.parse for AI messages to render Markdown
            if (sender === 'ai') {
                textElement.innerHTML = marked.parse(text); // Use innerHTML after parsing Markdown
            } else {
                textElement.textContent = text;
            }

            bubble.appendChild(textElement);

            if (sources.length > 0) {
                const sourceDiv = document.createElement('div');
                sourceDiv.className = 'mt-2 pt-2 border-t border-purple-500/20 text-xs text-gray-400';
                sourceDiv.innerHTML = '<strong>Sources:</strong> ' + sources.map((s, i) =>
                    `<a href="${s.uri}" target="_blank" class="text-purple-300 hover:text-purple-400 underline" rel="noopener noreferrer">${s.title} (${i + 1})</a>`
                ).join(', ');
                bubble.appendChild(sourceDiv);
            }

            wrapper.appendChild(bubble);
            chatContainer.appendChild(wrapper);
            return textElement;
        };


        /**
         * Simulates the AI "typing" out the response text.
         */
        const simulateTyping = (messageElement, fullText, delay = 10) => {
            return new Promise(resolve => {
                let charIndex = 0;
                // Temporarily disable Markdown parsing during typing simulation
                const rawText = fullText; 
                messageElement.textContent = ''; // Ensure it starts empty
                
                const typingInterval = setInterval(() => {
                    if (charIndex < rawText.length) {
                        messageElement.textContent += rawText[charIndex];
                        charIndex++;
                        scrollToBottom();
                    } else {
                        clearInterval(typingInterval);
                        // Re-render the full text with Markdown after typing is complete
                        messageElement.innerHTML = marked.parse(fullText);
                        resolve();
                    }
                }, delay);
            });
        };


        // --- API Call with Retries (Logic retained) ---

        const generateContentWithRetries = async (prompt, maxRetries = 5, initialDelay = 1000) => {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                tools: TOOLS,
                systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] },
            };

            for (let i = 0; i < maxRetries; i++) {
                let delay = initialDelay * Math.pow(2, i);

                try {
                    const response = await fetch(GEMINI_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 429 || response.status >= 500) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    } else {
                        const errorBody = await response.text();
                        console.error(`API Error (${response.status}): ${errorBody}`);
                        throw new Error(`API failed with status ${response.status}`);
                    }

                } catch (error) {
                    console.error('Fetch attempt failed:', error);
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw new Error('All API retries failed.');
                    }
                }
            }
        };

        // --- Main Form Submission Handler ---

        inputForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (isGenerating || !authReady) {
                console.log("Not ready or already generating.");
                return;
            }

            const userText = userInput.value.trim();
            if (!userText) return;

            // Clear the "Type anything now" message if it exists
            if (currentConversationId === null) {
                 chatContainer.innerHTML = '';
            }

            // 1. Disable UI
            isGenerating = true;
            sendButton.disabled = true;
            userInput.disabled = true;
            userInput.value = '';
            
            const isNewConversation = currentConversationId === null;
            let convIdToUse = currentConversationId;
            let titlePromise = Promise.resolve();
            
            // --- NEW CONVERSATION FLOW ---
            if (isNewConversation) {
                // 2a. Create new conversation document (placeholder title)
                const newConvDoc = await addDoc(getConversationCollectionRef(userId), {
                    title: 'untitled conversation...',
                    createdAt: serverTimestamp(),
                    lastActive: serverTimestamp()
                });
                convIdToUse = newConvDoc.id;
                
                // Immediately load the new conversation to update UI state and listeners
                loadConversation(convIdToUse, 'untitled conversation...');
                
                // 2b. Start title generation in the background
                titlePromise = generateTitle(userText, convIdToUse);
                
                // Set flag to false now that the user has started a chat
                isFirstTimeUser = false; 
            } else {
                // Update last active time for existing conversation
                const convDocRef = doc(getConversationCollectionRef(userId), convIdToUse);
                await updateDoc(convDocRef, { lastActive: serverTimestamp() });
            }
            
            // 3. Save user message
            await addDoc(getMessageCollectionRef(userId, convIdToUse), {
                sender: 'user',
                text: userText,
                sources: [],
                timestamp: serverTimestamp(),
            });

            // 4. Show local typing indicator and placeholder for typing simulation
            typingIndicatorWrapper.classList.remove('hidden');
            // We use setTimeout to ensure the firestore listener processes the user message first
            await new Promise(resolve => setTimeout(resolve, 100));
            const aiMessageElement = renderMessage('ai', '', [], true); // Create local placeholder
            scrollToBottom();

            let finalResponseText = "Sorry, PolarS1 couldn't generate a valid response.";
            let sources = [];

            try {
                // 5. Call the main API
                const result = await generateContentWithRetries(userText);
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    finalResponseText = candidate.content.parts[0].text;
                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                }

                // 6. Simulate Typing into the local placeholder
                await simulateTyping(aiMessageElement, finalResponseText);

                // 7. Persist the final AI message
                await addDoc(getMessageCollectionRef(userId, convIdToUse), {
                    sender: 'ai',
                    text: finalResponseText,
                    sources,
                    timestamp: serverTimestamp(),
                });

            } catch (error) {
                console.error('Chat generation failed:', error);
                finalResponseText = `An error occurred: ${error.message}. Please try again.`;
                // If it fails after typing, save the error message
                await addDoc(getMessageCollectionRef(userId, convIdToUse), {
                    sender: 'ai',
                    text: finalResponseText,
                    sources: [],
                    timestamp: serverTimestamp(),
                });

            } finally {
                // 8. Wait for title generation to finish
                await titlePromise; 
                
                // 9. Cleanup and reset UI
                const placeholder = document.getElementById('ai-typing-placeholder');
                if (placeholder) {
                    placeholder.remove();
                }

                typingIndicatorWrapper.classList.add('hidden');
                isGenerating = false;
                sendButton.disabled = false;
                userInput.disabled = false;
                userInput.focus();
                scrollToBottom();
            }
        });

        // Initialize Firebase on load and set up listeners
        document.addEventListener('DOMContentLoaded', () => {
            initFirebase();
            clearHistoryButton.addEventListener('click', clearAllHistory);
            newChatButton.addEventListener('click', startNewConversation);
            accessAssistantButton.addEventListener('click', startNewConversation); // Access button triggers new chat flow
            
            // Set focus to input for the "click enter" experience
            userInput.focus();
        });
    </script>
</body>
</html>
