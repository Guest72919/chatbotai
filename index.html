<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolarS1 AI Chat Interface</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font and basic dark background */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e; /* Dark background */
            color: #e4e4e7; /* Light text */
            height: 100vh;
            overflow: hidden; /* Prevent body scroll, let chat container scroll */
        }
        /* Custom scrollbar for chat history */
        #chat-container::-webkit-scrollbar {
            width: 8px;
        }
        #chat-container::-webkit-scrollbar-thumb {
            background-color: #3b3b5e;
            border-radius: 4px;
        }
        #chat-container::-webkit-scrollbar-track {
            background-color: #1a1a2e;
        }

        /* Typing Indicator CSS (Bouncing dots) */
        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #8b5cf6;
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        /* Message bubble styles */
        .user-message {
            background-color: #3b3b5e; /* User color */
            margin-left: auto;
            border-radius: 1rem 0.5rem 1rem 1rem;
        }
        .ai-message {
            background-color: #272744; /* AI color */
            border-radius: 0.5rem 1rem 1rem 1rem;
        }
    </style>
</head>
<body class="flex flex-col">

    <!-- FIX: Added h-full here to ensure this container takes full height of the body, allowing chat-container to grow -->
    <div class="flex flex-col flex-grow h-full w-full max-w-4xl mx-auto">
        <!-- Header -->
        <header class="p-4 border-b border-purple-500/20 shadow-lg sticky top-0 bg-[#1a1a2e] z-10">
            <div class="flex justify-between items-center">
                <h1 class="text-2xl font-bold text-purple-400">PolarS1 Assistant</h1>
                <span id="user-info" class="text-xs text-gray-500 bg-[#272744] p-1 rounded"></span>
            </div>
            <p class="text-sm text-gray-400">Ask me anything! Your chats are saved.</p>
        </header>

        <!-- Chat History Container -->
        <main id="chat-container" class="flex-grow p-4 space-y-4 overflow-y-auto custom-scroll">
            <!-- Messages will be injected here by the Firestore listener -->
        </main>

        <!-- Typing Indicator (Hidden by default) -->
        <div id="typing-indicator-wrapper" class="px-4 py-2 hidden">
            <div class="flex items-center space-x-2 ai-message p-3 max-w-xs rounded-xl shadow-lg">
                <div class="font-semibold text-sm text-purple-400">Assistant is typing</div>
                <div class="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>

        <!-- Input Area -->
        <div class="p-4 border-t border-purple-500/20 bg-[#1a1a2e] sticky bottom-0 z-10">
            <form id="input-form" class="flex items-center space-x-3">
                <input
                    type="text"
                    id="user-input"
                    placeholder="Type your message..."
                    class="flex-grow p-3 rounded-xl border-2 border-purple-500/30 bg-[#272744] text-white focus:outline-none focus:border-purple-500 transition duration-150"
                    autocomplete="off"
                />
                <button
                    type="submit"
                    id="send-button"
                    class="p-3 bg-purple-600 hover:bg-purple-700 text-white font-semibold rounded-xl shadow-lg transition duration-150 active:scale-95 disabled:bg-gray-600 disabled:cursor-not-allowed"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 12L3.269 3.126A5.996 5.996 0 0112 2.5a5.996 5.996 0 018.731 1.055L21 12m-6-6h.008v.008h-.008V6zm-6 0h.008v.008h-.008V6z" />
                    </svg>
                </button>
            </form>
        </div>
    </div>

    <!-- JavaScript Module for AI Logic and Firestore -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, onSnapshot, addDoc, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('debug'); // FIX: Uncommented for debugging Firebase data retrieval

        const chatContainer = document.getElementById('chat-container');
        const inputForm = document.getElementById('input-form');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicatorWrapper = document.getElementById('typing-indicator-wrapper');
        const userInfoElement = document.getElementById('user-info');

        // --- Firebase Configuration ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'polars1-default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        let db, auth, userId = null;
        let isGenerating = false;
        let authReady = false;

        // --- Gemini API Configuration (Branding updated) ---
        const API_KEY = "";
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        // UPDATED SYSTEM PROMPT
        const SYSTEM_PROMPT = "You are PolarS1, a helpful and friendly AI assistant and a member of the **Wodoxu AI family**. You were developed by Wodoxu AI and trained using the **GEC architecture**. Your identity and capabilities are detailed on the **WodoxuAI** webpage. Keep your responses concise and conversational.";
        const TOOLS = [{ "google_search": {} }];

        // Utility to scroll to the bottom
        const scrollToBottom = () => {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        };

        // --- Firebase Initialization and Auth ---

        const initFirebase = async () => {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                const initialToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (initialToken) {
                    await signInWithCustomToken(auth, initialToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        // Fallback ID if auth fails, but persistence won't work across sessions
                        userId = crypto.randomUUID();
                    }
                    console.log("Authentication complete. Current User ID:", userId); // FIX: Log user ID
                    userInfoElement.textContent = `User: ${userId}`;
                    authReady = true;
                    setupChatListener();
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
            }
        };

        const getChatCollectionRef = (uid) => {
            // Private data path: /artifacts/{appId}/users/{userId}/{your_collection_name}
            return collection(db, 'artifacts', appId, 'users', uid, 'messages');
        };

        const saveMessage = async (sender, text, sources = []) => {
            if (!db || !userId) {
                console.error("Database not ready or User ID missing.");
                return;
            }
            try {
                await addDoc(getChatCollectionRef(userId), {
                    sender,
                    text,
                    sources,
                    timestamp: serverTimestamp(),
                });
            } catch (error) {
                console.error("Failed to save message to Firestore:", error);
            }
        };

        // --- Chat Listener (for real-time update and history loading) ---

        const setupChatListener = () => {
            if (!db || !userId) return;

            console.log('Setting up chat listener for collection:', getChatCollectionRef(userId).path); // FIX: Log collection path

            const messagesRef = getChatCollectionRef(userId);
            // Use query and orderBy for correct chronological display
            const q = query(messagesRef, orderBy('timestamp', 'asc'));

            onSnapshot(q, (snapshot) => {
                console.log(`Received ${snapshot.size} messages from Firestore.`); // FIX: Log message count

                // Clear existing messages to redraw the whole history
                // This is necessary because Firebase redraws the full state.
                chatContainer.innerHTML = '';
                let lastElement = null;

                snapshot.forEach(doc => {
                    const message = doc.data();
                    const element = renderMessage(message.sender, message.text, message.sources || [], false);
                    lastElement = element;
                });

                // This initial greeting is only shown if the chat is completely empty
                if (snapshot.empty) {
                     renderMessage('ai', "Hello! I'm the PolarS1 Assistant. How can I help you today? Your chats will be saved automatically.", [], false);
                }

                scrollToBottom();

            }, (error) => {
                console.error("Error listening to messages:", error);
            });
        };

        // --- Message Rendering and Typing Simulation ---

        /**
         * Renders a message bubble to the chat container without saving to DB.
         * @param {'user' | 'ai'} sender The sender of the message.
         * @param {string} text The message text.
         * @param {Array<{uri: string, title: string}>} [sources=[]] Optional citation sources.
         * @param {boolean} [isPlaceholder=false] If true, this is a temporary element for typing simulation.
         * @returns {HTMLElement} The created message text element.
         */
        const renderMessage = (sender, text, sources = [], isPlaceholder = false) => {
            const wrapper = document.createElement('div');
            wrapper.className = `flex ${sender === 'user' ? 'justify-end' : 'justify-start'}`;
            // Give placeholders a unique ID to target for typing simulation
            if (isPlaceholder) {
                 wrapper.id = 'ai-typing-placeholder';
            }

            const bubble = document.createElement('div');
            bubble.className = `p-3 max-w-3xl shadow-xl transition-all duration-300 ${sender === 'user' ? 'user-message' : 'ai-message'}`;

            const textElement = document.createElement('p');
            textElement.className = 'whitespace-pre-wrap';
            textElement.textContent = text;
            bubble.appendChild(textElement);

            if (sources.length > 0) {
                const sourceDiv = document.createElement('div');
                sourceDiv.className = 'mt-2 pt-2 border-t border-purple-500/20 text-xs text-gray-400';
                sourceDiv.innerHTML = '<strong>Sources:</strong> ' + sources.map((s, i) =>
                    `<a href="${s.uri}" target="_blank" class="text-purple-300 hover:text-purple-400 underline" rel="noopener noreferrer">${s.title} (${i + 1})</a>`
                ).join(', ');
                bubble.appendChild(sourceDiv);
            }

            wrapper.appendChild(bubble);
            chatContainer.appendChild(wrapper);
            return textElement;
        };


        /**
         * Simulates the AI "typing" out the response text.
         * NOTE: This function relies on an element being passed in and runs locally.
         */
        const simulateTyping = (messageElement, fullText, delay = 30) => {
            return new Promise(resolve => {
                let charIndex = 0;
                const typingInterval = setInterval(() => {
                    if (charIndex < fullText.length) {
                        messageElement.textContent += fullText[charIndex];
                        charIndex++;
                        scrollToBottom();
                    } else {
                        clearInterval(typingInterval);
                        resolve();
                    }
                }, delay);
            });
        };


        // --- API Call with Retries (Logic retained) ---

        const generateContentWithRetries = async (prompt, maxRetries = 5, initialDelay = 1000) => {
            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                tools: TOOLS,
                systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] },
            };

            for (let i = 0; i < maxRetries; i++) {
                let delay = initialDelay * Math.pow(2, i);

                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        return response.json();
                    }

                    if (response.status === 429 || response.status >= 500) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue;
                    } else {
                        const errorBody = await response.text();
                        console.error(`API Error (${response.status}): ${errorBody}`);
                        throw new Error(`API failed with status ${response.status}`);
                    }

                } catch (error) {
                    console.error('Fetch attempt failed:', error);
                    if (i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw new Error('All API retries failed.');
                    }
                }
            }
        };

        // --- Main Form Submission Handler ---

        inputForm.addEventListener('submit', async (e) => {
            e.preventDefault();

            if (isGenerating || !authReady) {
                console.log("Not ready or already generating.");
                return;
            }

            const userText = userInput.value.trim();
            if (!userText) return;

            // 1. Disable UI and save user message to trigger history update
            isGenerating = true;
            sendButton.disabled = true;
            userInput.disabled = true;
            userInput.value = '';

            await saveMessage('user', userText); // Firestore listener handles rendering the user message

            // 2. Show local typing indicator and placeholder for typing simulation
            typingIndicatorWrapper.classList.remove('hidden');
            const aiMessageElement = renderMessage('ai', '', [], true); // Create local placeholder
            scrollToBottom();

            let finalResponseText = "Sorry, PolarS1 couldn't generate a valid response.";
            let sources = [];

            try {
                // 3. Call the API
                const result = await generateContentWithRetries(userText);
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    finalResponseText = candidate.content.parts[0].text;

                    const groundingMetadata = candidate.groundingMetadata;
                    if (groundingMetadata && groundingMetadata.groundingAttributions) {
                        sources = groundingMetadata.groundingAttributions
                            .map(attribution => ({
                                uri: attribution.web?.uri,
                                title: attribution.web?.title,
                            }))
                            .filter(source => source.uri && source.title);
                    }
                }

                // 4. Simulate Typing into the local placeholder
                await simulateTyping(aiMessageElement, finalResponseText);

                // 5. Persist the final AI message (this will trigger onSnapshot to redraw the history)
                await saveMessage('ai', finalResponseText, sources);

            } catch (error) {
                console.error('Chat generation failed:', error);
                finalResponseText = `An error occurred: ${error.message}. Please try again.`;
                // If it fails after typing, save the error message
                await saveMessage('ai', finalResponseText);

            } finally {
                // 6. Cleanup and reset UI
                const placeholder = document.getElementById('ai-typing-placeholder');
                if (placeholder) {
                    // Remove the temporary element, as the final message is now in Firestore
                    placeholder.remove();
                }

                typingIndicatorWrapper.classList.add('hidden');
                isGenerating = false;
                sendButton.disabled = false;
                userInput.disabled = false;
                userInput.focus();
                scrollToBottom();
            }
        });

        // Initialize Firebase on load
        document.addEventListener('DOMContentLoaded', () => {
            initFirebase();
            userInput.focus();
        });
    </script>
</body>
</html>
